//! Unit tests for multi-pass dispatch with actual on_pointer_event calls

use crate::input::HitPathTracker;
use compose_core::{MemoryApplier, NodeId};
use compose_foundation::nodes::input::types::{PointerEvent, PointerEventKind, PointerEventPass};
use compose_ui_graphics::Point;
use std::cell::RefCell;
use std::rc::Rc;

/// Track which passes were called
#[derive(Debug, Clone, Default)]
struct CallTracker {
    calls: Rc<RefCell<Vec<(NodeId, PointerEventPass)>>>,
}

impl CallTracker {
    fn new() -> Self {
        Self {
            calls: Rc::new(RefCell::new(Vec::new())),
        }
    }
    
    fn record(&self, node_id: NodeId, pass: PointerEventPass) {
        self.calls.borrow_mut().push((node_id, pass));
    }
    
    fn get_calls(&self) -> Vec<(NodeId, PointerEventPass)> {
        self.calls.borrow().clone()
    }
    
    fn clear(&self) {
        self.calls.borrow_mut().clear();
    }
}

#[test]
fn test_multi_pass_dispatch_order() {
    // This test verifies that dispatch happens in the correct order:
    // Parent Initial -> Child Initial -> Child Main -> Parent Main -> Parent Final -> Child Final
    
    let tracker = CallTracker::new();
    let mut hit_path_tracker = HitPathTracker::new();
    
    // Simulate a hit path: parent (node 1) -> child (node 2)
    let parent_id = 1;
    let child_id = 2;
    
    hit_path_tracker.add_hit_path(0, vec![parent_id, child_id]);
    
    // Create a simple event
    let event = PointerEvent::new(vec![], None);
    
    // TODO: Actually dispatch and verify order
    // Expected order:
    // 1. Parent Initial (tunneling)
    // 2. Child Initial (tunneling)
    // 3. Child Main (bubbling)
    // 4. Parent Main (bubbling)
    // 5. Parent Final (tunneling)
    // 6. Child Final (tunneling)
    
    // For now, this test will fail until we wire up the actual calls
    // let calls = tracker.get_calls();
    // assert_eq!(calls.len(), 6);
    // assert_eq!(calls[0], (parent_id, PointerEventPass::Initial));
    // assert_eq!(calls[1], (child_id, PointerEventPass::Initial));
    // assert_eq!(calls[2], (child_id, PointerEventPass::Main));
    // assert_eq!(calls[3], (parent_id, PointerEventPass::Main));
    // assert_eq!(calls[4], (parent_id, PointerEventPass::Final));
    // assert_eq!(calls[5], (child_id, PointerEventPass::Final));
}

#[test]
fn test_event_consumption() {
    // Test that consumption works across passes
    let event = PointerEvent::new(vec![], None);
    
    assert!(!event.is_consumed());
    event.consume();
    assert!(event.is_consumed());
}

#[test]
fn test_add_hit_path_merging() {
    let mut tracker = HitPathTracker::new();
    
    // Add first path
    tracker.add_hit_path(1, vec![1, 2]);
    
    // Add overlapping path - should merge
    tracker.add_hit_path(2, vec![1, 3]);
    
    // Both paths share node 1, so it should be reused
    // This is verified internally by the tree structure
}
